Завдання 4.1

Річ у тім, що адресний простір процесів у 64-бітній архітектурі зазвичай обмежений до 48 біт. 
Тобто ядро ОС та компілятор використовують лише нижні 48 біт адреси, що дозволяє адресувати:
2^48 = 256 Тбайт. Зазвичай у користувацькому просторі пам’яті (user space) доступно лише 
половина цього обсягу, тобто: 2^47 = 128 Тбайт. Таким чином, максимальний обсяг виділеної 
пам’яті за один виклик malloc() теоретично обмежується 8 Ебайтами через обмеження на адресний 
простір.

Завдання 4.2

Функція malloc() приймає як параметр значення типу size_t, яке є беззнаковим цілим числом. Якщо 
передати від’ємне значення (наприклад, -1), воно буде інтерпретоване як велике позитивне число 
через автоматичне перетворення типів.

Завдання 4.3

Функція malloc(0) поводиться неоднозначно згідно зі стандартом C. Вона може повернути:
 * NULL — якщо виділення пам’яті неможливе або не має сенсу.
 * Некоректний, але валідний вказівник — який можна передати у free().
Реальна поведінка залежить від реалізації бібліотеки C та операційної системи.

Завдання 4.4

Пам'ять звільняється на кожній ітерації циклу. Після виклику free(ptr); значення ptr стає 
недійсним, але не встановлюється назад у NULL. Якщо умова спрацьовує на наступній ітерації 
(if (!ptr)), програма не виконає повторний виклик malloc() — в результаті код використовує
звільнений вказівник. Використання звільненого вказівника — це undefined behavior (UB), що може 
призвести до аварійного завершення програми або непередбачуваних результатів

Завдання 4.5

Якщо функція realloc() не може виділити пам’ять, вона:
Повертає NULL — це означає, що виділення не вдалося.
Залишає вихідний вказівник без змін — раніше виділена пам’ять не звільняється.

Завдання 4.6

Якщо передати NULL у realloc():
 * Це еквівалентно виклику malloc().
 * Виділяється новий блок пам’яті розміром size.
Якщо передати розмір 0 у realloc():
 * Поведінка залежить від реалізації:
 * Деякі реалізації можуть повертати NULL (якщо виділення не вдалося).
 * Інші можуть повернути валідний вказівник, який можна звільнити через free().
Якщо вказівник не NULL та розмір 0, стандарт дозволяє повернути або NULL, або мінімальний
виділений блок.
У будь-якому випадку початковий блок пам'яті звільняється.

Завдання 4.7

Використання reallocarray() є більш безпечним, оскільки воно забезпечує правильне множення 
кількості елементів і їхнього розміру, тим самим знижуючи ймовірність переповнення при 
неправильному розрахунку.

Завдання 4.10

Розподіл пам'яті здійснюється через низку механізмів управління пам'яттю, включаючи malloc(), 
realloc(), і free(), що працюють з системними викликами brk() або mmap(). Використання таких 
інструментів, як ltrace, дозволяє глибше зрозуміти, як відбувається взаємодія з пам'яттю на 
рівні системи.
