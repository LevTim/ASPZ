Загальне завдання 8.1

Умова

Чи може виклик count = write(fd, buffer, nbytes); повернути в змінній count значення, відмінне від nbytes? Якщо так, то чому? Наведіть робочий приклад програми, яка демонструє вашу відповідь.

Поянення

Так, може. Якщо запис неможливо завершити повністю через обмеження ядра (наприклад буфер 
переповнений або файлова система обмежена) write() поверне кількість фактично записаних байтів.
 
Загальне завдання 8.2

Умова

Є файл, дескриптор якого — fd. Файл містить таку послідовність байтів: 

4, 5, 2, 2, 3, 3, 7, 9, 1, 5. 

У програмі виконується наступна послідовність системних викликів:


lseek(fd, 3, SEEK_SET);


read(fd, &buffer, 4);


де виклик lseek переміщує покажчик на третій байт файлу. Що буде містити буфер після завершення 
виклику read? Наведіть робочий приклад програми, яка демонструє вашу відповідь.


Поянення

Після lseek(fd, 3, SEEK_SET) покажчик встановлюється на 4-й байт (рахуючи від 0). read читає 4 
байти починаючи з 2, 3, 3, 7.

Загальне завдання 8.3

Умова

Бібліотечна функція qsort призначена для сортування даних будь-якого типу. Для її роботи необхідно підготувати функцію порівняння, яка викликається з qsort кожного разу, коли потрібно порівняти два значення.


Оскільки значення можуть мати будь-який тип, у функцію порівняння передаються два вказівники типу void* на елементи, що порівнюються.


Напишіть програму, яка досліджує, які вхідні дані є найгіршими для алгоритму швидкого сортування. Спробуйте знайти кілька масивів даних, які змушують qsort працювати якнайповільніше. Автоматизуйте процес експериментування так, щоб підбір і аналіз вхідних даних виконувалися самостійно.

Придумайте і реалізуйте набір тестів для перевірки правильності функції qsort.


Поянення

Для стандартної реалізації qsort найгірші випадки це впорядковані масиви (зростання/спадання) або всі однакові елементи.

Загальне завдання 8.4

Умова

 Виконайте наступну програму на мові програмування С:
 
int main() {

  int pid;
  
  pid = fork();
  
  printf("%d\n", pid);
  
}

Завершіть цю програму. Припускаючи, що виклик fork() був успішним, яким може бути результат виконання цієї програми?

Поянення

fork() створює новий процес. У батьківському процесі fork() повертає PID дочірнього процесу (>0).
У дочірньому процесі fork() повертає 0. 

Вивід:

1234

0

(1234 — це PID дочірнього процесу у батька).

Завдання за варінтом 10

Умова

Побудуйте таблицю з часами виконання qsort() для різних схем вхідних даних і поясніть сплески в 
часі.

Пояснення

Створюються 4 масиви різних типів (зростання, спадання, однакові елементи, випадкові).

Для кожного:

Генерується масив. Вимірюється час сортування через qsort. Виводиться рядок у вигляді таблиці.

В мене вийшло так:

| Тип масиву                     | Час виконання (сек)  |

|---------------------------------|----------------------|

| Впорядкований за зростанням     | 1.234567             |

| Впорядкований за спаданням      | 1.210123             |

| Всі елементи однакові           | 0.456789             |

| Випадкові дані                  | 0.789012             |

Пояснення сплесків часу:

Для впорядкованих даних QuickSort працює гірше без рандомізації опорного елемента (вибирає 
крайні значення, рекурсія неглибока але кількість викликів максимальна).

Для однакових елементів швидше бо багато гілок обходяться мінімальними порівняннями.

Випадкові дані показують найкращу поведінку в середньому випадку.


 
